// -*- coding: utf-8 -*-
:encoding: UTF-8

Olibs framtid
=============
Lars Hagström
16 Oktober 2014

== Bakgrund

Olib är den komponent i Safir SDK Core som tillhandahåller en databasgränsyta i C++. Olib
är en "wrapper" runt ODBC som försöker tillhandahålla ett generellt C-API till
databaser.

Dagens Olib har egentligen bara fullt stöd för databasmotorn Mimer SQL på Windows. För
övriga databaser och plattformar finns bara begränsat stöd.

Det här dokumentets syfte är att beskriva de problem som finns med Olib och att föreslå
lösningar för att tillhandahålla databasstöd i Safir SDK.

== Problemen

=== Begr&auml;nsat databasst&ouml;d

Olib har bara fullt stöd för kombinationen Mimer SQL och Windows. Olib går även att
använda mot MySQL på Linux, men bara på Ubuntu/Debian, och utan stöd för vissa
kolumntyper, och inte på RedHat/Centos. På RedHat/Centos går det däremot att använda
Mimer SQL.

De här begränsningarna beror på ett par saker:

Odbc-gränsytor::
På Windows finns det ett ODBC-API, medans det på Linux finns två olika, UnixODBC och
iODBC. De två på Linux är inte helt kompatibla med varandra, bland annat i hanteringen av
wide-strängar. Olika Linux-distributioner använder olika ODBC-gränsytor, och exempelvis
har iODBC betraktats som deprecated av Debian (jag är osäker på om det fortfarande
gäller, utvecklingen av iODBC verkar ha tagit fart igen efter några års träda).

Stränghantering::
UnixODBC och iODBC har olika bredder på wide-strängar, 4 respektive 2 bytes, och Linux i
sig har 4 bytes. Windows-implementationen använder 2 bytes, vilket även är Windows egen
wideteckenbredd. Eftersom användare av Olib v1 exponeras för delar av detta blir det
väldigt svårt att skriva plattforms- och databasoberoende applikationer.

=== Datumtyper

Olika databaser har olika bra stöd för datumtyper. Speciellt handlar det om upplösningen
när man vill ha högre noggrannhet än sekunder. Eventuellt kan någon speciallösning
behövas för vissa databaser.

=== Licenshantering

Vid användning av en kommersiell licens av Mimer SQL så behövs några extra anrop för att
injicera licensnycklar vid anslutning till databasen. Detta har Olib i Safir SDK Core
inget stöd för idag. Åtminstone en av våra kunder har gjort en fork av Olib för att
hantera detta, vilket ju är långt ifrån en ideal lösning.

=== Exponering av ODBC-typer

Gränsytan till Olib exponerar alla ODBCs datatyper, vilket även medför att windows.h
visas upp för användaren.

== Lösning - använd tredjepartsprodukt

Det finns ett antal potentiella tredjepartsprodukter som man skulle kunna använda
istället för Olib.

 * QtSQL
 * SOCI
 * SQLAPI++

SQLAPI++ är den som verkar mest lovande just nu, och det är den vi tittat närmare på.

=== SQLAPI++

Är "shareware", med en licenskostnad på 900 dollar för en livstids site-licens för
utveckling. Ingen runtimelicens krävs.

Vid köp av licens får man tillgång till källkoden och kan alltså själv kompilera binärer
med det stöd som man vill ha.

==== Allmänt

Jag har provat SQLAPI++ mot MS SQL Server, Mimer SQL och PostgreSQL på Windows 7, och
mot Mimer SQL på Linux.

Det första intrycket är att det fungerar rätt bra. Interfacen ser relativt bra ut, och
fungerar väl. Dock så blir det ganska snabbt problem när man interfacear mot flera olika
databaser med samma kod. Detta är dock inte riktigt SQLAPI++s fel, utan snarare ett
resultat av att databaserna har olika bra stöd för olika operationer.

==== Support

Jag har ställt några frågor till SQLAPI++s support och de (eller han, oklart hur många
de är) har svarat inom en timme på en del ganska tekniska frågor. Så de verkar vara
ganska rappa på att hjälpa till. De är inte "native English speakers", men fullt
förståeligt.

==== Exceptions

De exceptions som SQLAPI++ kastar ärver inte av std::exception per default. Dock finns möjlighet
att konfigurera detta i compile-time.

==== UTF-8 och Unicode

SQLAPI\++ har stöd för ASCII/Codepages, UTF-8, UTF-16 och UTF-32 (på Linux). Här gäller
det att hålla tungan rätt i mun för att få till kod som fungerar mot alla databaser och
på båda plattformarna. Men det har ju än en gång inte rigtigt med SQLAPI++ att göra,
utan är mer ett resultat av hur databaser fungerar.

Under ytan så använder SQLAPI++ "rätt" encoding när den kommunicerar med
databasen. Från Sergey: "Unicode SQLAPI passes UTF-16 / UTF-32 / UTF-8 data - depends on
DBMS API. For example Oracle always use UTF16, MySQL - UTF8, ODBC - how it is defined at
the compilation time."

==== 64-bit typer

För att få ut en int64 ur databasen så måste man gå en liten omväg via en datatyp som
heter SANumeric, vilket är lite oelegant. Oklart om det har någon prestandapåverkan.

==== Piecewise BLob

SQLAPI++ har stöd för SQLPutData/SQLGetData via ODBC, med något som de kallar Piecewise
BLobs. Det fungerade bra mot MS SQL Server, men inte mot Mimer SQL eller PostgreSQL. Vad
gäller PostgreSQL så har dess native-api inte stöd för detta alls, och varför det inte
fungerar på Mimer vet jag inte.

Från Sergey: "For piecewise operations SQLAPI uses SQLPutData/SQLGetData instead of
buffer binding (parameter of field data). I can say that SQL Server is the reference ODBC
driver for us. The other driver implementation can be wrong or limited and we never
correct the ODBC layer code for any special ODBC driver."

Så i det här fallet får man, om man vill skriva databasoberoende kod, låta bli att
använda piecewise BLobs. Man skulle ju kunna göra det mot vissa databaser som en
optimering som slås på beroende på databasval.

== Förkastad lösning - Uppdatera Olib

Denna lösning är för närvarande inte aktuell. Vi tittar just nu på tredjepartsbibliotek
som skulle kunna ersätta Olib.

Målsättningen med Olib v2 är att införa stöd för fler databaser, och att göra det lättare
att lägga till ännu fler databaser i framtiden. Ett absolut minimum är stöd för följande
databaser:

 * Mimer SQL
 * MySQL
 * Microsoft SQL Server

Därutöver skulle det vara bra om PostgreSQL stöddes.

På Linux bör både UnixODBC och iODBC stödjas.

Någon form av API som gör det möjligt att sköta Mimer SQLs licenshantering skall läggas till.

Alla dessa saker skall stödjas utan att man måste kompilera om Olib, och om möjligt så
bör Olib v2 vara bakåtkompatibelt med Olib v1 under ett antal releaser.

Olib v2 bör inte visa upp några av typerna från ODBC, utan skall dölja dessa bakom
ytan. Detta gör att det blir lättare att upptäcka problem vid portering till nya
plattformar och databaser, och att det blir lättare att skriva applikationer som stödjer
flera plattformar.


=== F&ouml;rslag

==== Str&auml;nghantering

Vi skulle vilja låta Olib v2 använda en och samma strängtyp på både Windows,
Linux/UnixODBC och Linux/iODBC. Förslaget är att använda +std::string+ med
UTF-8-encoding. Det faller då på applikationerna att konvertera till och från
+std::wstring+ och +std::string+ när så behövs.

Då kan Olib använda UTF-8-strängar mot de databaser som stödjer detta, och för de
databaser (exempelvis Microsoft SQL Server) som inte stödjer UTF-8 så kan den konvertera
till det teckenformat som passar bäst (UCS-2 i MS SQL-fallet).

Ifall det visar sig att någon applikation får prestandaproblem med denna lösning,
exempelvis en applikation som skriver väldigt mycket strängar i ett system med en MS
SQL-databas, så är det enkelt att lägga till ett icke-portabelt optimerat API för att
slippa de extra konverteringarna.

Information om hur databaserna hanterar UTF-8:

PostgreSQL:: Fullt stöd för UTF-8.

MySQL:: Stöd för UTF-8, men bara för sekvenser på upp till 3 bytes. Dvs 4-bytessekvenser stöds ej.

Mimer SQL:: Fullt stöd för UTF-8.

Microsoft SQL Server:: Har ej stöd för UTF-8. Lagring av Unicode sker med UCS-2.

==== Eliminera ODBC-typer i gr&auml;nsytan

Olib v1:s gränsytor består av mycket templates som är instantierade med ODBC-typer,
vilket genererar beroenden till sql.h och windows.h. Om det är möjligt - utan att göra
alltför stora gränsyteändringar - bör dessa beroenden flyttas ner i cpp-filerna, så att
beroendena hamnar bakom dll-gränsytan.

Det gör att exempelvis kopplingen mellan +SQL_C_FLOAT+, SQL_FLOAT+ och
+Safir::Dob::Typesystem::Float32+ inte blir en del av den publika gränsytan, utan
användaren ser bara Dob-typen. Vid portering till en ny plattform eller databas där denna
koppling inte är korrekt så kan man ändra under ytan utan att påverka användaren.

==== St&ouml;d f&ouml;r b&aring;de UnixODBC och iODBC

Om vi löser stränghanteringsproblematiken enligt ovanstående förslag så innebär det
troligen att vi kommer att stödja både UnixODBC och iODBC. Om vi dessutom lyckas
eliminera ODBC-typerna i gränsytan så bör det dessutom vara möjligt att stödja både
UnixODBC och iODBC utan omkompilering av Olib.

=== Konsekvenser f&ouml;r existerande applikationer

De föreslagna ändringarna är inte fullt bakåtkompatibla. I synnerhet är det hanteringen
av strängar som kommer att ändras. En förutsättning för de andra förändringarna är att de
kan göras utan stor påverkan på applikationerna.

Eftersom Olib v2:s gränsyta kommer att använda +std::string+ och +char+ istället för
+std::wstring+ och +SQL_WCHAR+ så kommer förändringar att behöva göras i alla
applikationer som skriver strängar till databas. I det enklaste fallet så är det bara att
anropa +ToUtf8(...)+ på strängarna innan de skickas till Olib.

Förutom rena kodändringar kommer även databastabellerna att behöva uppdateras. Med Olib
v1 så använder man bland annat NVARCHAR och NCLOB för korta respektive långa
strängkolumner. Dessa kommer att behöva ändras till att vara VARCHAR och CLOB för att
fungera med en databas som kan lagra UTF-8-data. I en MS SQL-databas kommer det dock att
även i fortsättningen vara NVARCHAR och NCLOB, eftersom MS SQL inte stödjer UTF-8.


=== Automattester

Eftersom det finns många kombinationer av databaser, operativsystem och ODBC-gränsytor så
är det mycket viktigt att få till så heltäckande automattester som möjligt. De tester som
finns idag är nära detta, men en del arbete behövs på dem, för att täcka alla
datatyper. Dessutom kan en del arbete behövas med att anpassa dem till att stödja de nya
databaserna.

Givetvis behövs även de nya databaserna läggas till i testmiljön.

=== Tidsuppskattning

Vi uppskattar att detta jobb tar 4 veckor för implementation och 4 veckor för automattester.

En viss osäkerhet finns i dessa siffror då det kan visa sig att något av våra antaganden
inte håller för någon databas. Siffrorna baserar sig på de antaganden vi gjort från
tolkning av dokumentationen för databaserna. En erfarenhet av databaser är att det finns
ganska mycket beteenden som inte är helt lätta att förstå innan man faktiskt skrivit
koden och testat den.

